#!/bin/sh
#!perl
# GENERATED FILE:  DO NOT EDIT OR READ THIS FILE
# Instead, read or edit the NoWeb file(s) from which this was generated.
eval 'exec perl -x -f "$0" "$@"'
  if 0;

use strict;

my (@notext, @textfile, @textline, %chunks, %parmchunks);
# note: $parm_re's first capture group is the parameter
#       $parm_re's second cpature group is for recursion (ignore!)
my $parm_re = '(\(\@[^)]*\)|(?<!@)\[\[((?:[^][]|\[(?-1)\])*)\]\])';
sub strip_chunkname($)
{
  my $n = shift;
  $n =~ s/$parm_re/(@)/g;
  return $n;
}
sub find_best_def($$) {
  my ($loc, $curchunk) = @_;
  my $pchunks = $parmchunks{strip_chunkname $curchunk};
  return if not $pchunks;
  my ($best, $best_len, %best_parms, @best_parms_loc);
  $best_len = length $curchunk;
  my @ambig;
  PCHUNK: foreach my $may (keys %$pchunks) {
    my $len = 0;
    my (%may_parms, @may_parms_loc);
    my $mayrest = $may;
    my $currest = $curchunk;
    while($mayrest =~ /$parm_re(.*)/) {
      my $mayp = $1;
      $mayrest = $3;
      $currest =~ /$parm_re(.*)/;
      my $curp = $1;
      $currest = $3;
      next if $curp eq $mayp;
      next PCHUNK if substr($mayp, 0, 1) eq "[" or substr($curp, 0, 1) eq "(";
      $len++;
      $may_parms{substr($mayp, 1, -1)} = substr($curp, 2, -2);
      push @may_parms_loc, length $mayrest;
    }
    next if $len > $best_len;
    if($len == $best_len) {
      push @ambig, $best if $#ambig < 1;
      push @ambig, $may;
      for(my $i = 0; $i <= $#may_parms_loc; $i++) {
        next PCHUNK if $may_parms_loc[$i] < $best_parms_loc[$i];
        last if $may_parms_loc[$i] > $best_parms_loc[$i];
      }
    } else {
      @ambig = undef;
    }
    $best = $may;
    $best_len = $len;
    %best_parms = (%may_parms);
    @best_parms_loc = (@may_parms_loc);
  }
  if($#ambig > 0) {
    print STDERR $loc . "ambiguous expansion of <<$curchunk>>:\n";
    foreach my $may (@ambig) {
      print "  <<$may>>\n";
      print " (chosen)" if $may eq $best;
      print "\n";
    }
  }
  return ($best, %best_parms);
}

sub idx_to_loc($) {
  my $idx = $_[0];
  return "$textfile[$idx]:$textline[$idx]: ";
}
sub dump_def($$$%) {
  my ($new, $prefix, $old, %parms) = @_;
  my ($ret, $subdefs);
  my $chunk = $chunks{$old};
  $chunks{$new} = [];
  for(my $c = 0; $c <= $#$chunk; $c += 2) {
    my $i = $$chunk[$c];
    my $last = $$chunk[$c + 1];
    $ret .= "\@file $textfile[$i]\n\@line " . ($textline[$i] + 1) . "\n";
    $ret .= substr($notext[$i], 0, -(length($old) + 1)) . $new . "\n";
    for($i++; $i <= $last; $i++) {
      my $t = $notext[$i];
      if($t !~ /^\@use (.*)$/) {
        $ret .= $t;
      } else {
        if(substr($1, 0, 1) eq '@') {
          # note: no newlines supported in parm vals due to syntax
          if($parms{$1}) {
            $ret .= "\@text $parms{$1}\n";
          } else {
            # again, we're not notangle, so can't raise errors here
            #print STDERR "$textfile[$i]:$textline[$i]: " .
            #             "undefined parameter <<$1>>\n" unless $parms{$1};
            # but we can force notangle to raise an error:
            $ret .= $t;
          }
        } else {
          my $new_chunk = $1;
          my ($best, %best_parms) = find_best_def(idx_to_loc($i), $new_chunk);
          if($best) {
            my %new_parms = (%parms);
            my $parms_changed;
            foreach my $p (keys %best_parms) {
              my $v = $best_parms{$p};
              my $newv = '';
              my $vrest = $v;
              while($vrest =~ /(.*?)(?<!@)<<(@.*?(?<!@))>>(.*)/) {
                $newv .= $1 . $parms{$2};
                $vrest = $3;
                # once again, can't print error because we're not notangle
                #print STDERR "$textfile[$i]:$textline[$i]: " .
                #             "undefined parameter <<$2>>\n" if not $parms{$2};
              }
              $newv .= $vrest;
              if($newv ne $v) {
                # since value changed, maybe best fit changed as well
                $new_chunk =~ s/(?<!@)\[\[$v\]\]/[[$newv]]/;
                $parms_changed = 1;
              }
            }
            ($best, %best_parms) = find_best_def(idx_to_loc($i), $new_chunk) if $parms_changed;
            foreach my $p (keys %best_parms) {
              $new_parms{$p} = $best_parms{$p};
            }
            # add w/ uniquifier prefix if implicit parms referenced
            my $has_ref = has_parmref($best, \%new_parms, \%best_parms);
            my $sub_name = $has_ref ? $prefix . $new_chunk : $new_chunk;
            $ret .= "\@use $sub_name\n";
            # skip if already there
            next if $chunks{$sub_name};
            $subdefs .= dump_def($sub_name, $sub_name, $best, %new_parms);
          } else {
            my $has_ref = has_parmref($best, \%parms, undef);
            my $sub_name = $has_ref ? $prefix . $new_chunk : $new_chunk;
            $ret .= "\@use $sub_name\n";
            # skip if already there
            next if $chunks{$sub_name};
            $subdefs .= dump_def($sub_name, $prefix, $new_chunk, %parms);
          }
        }
      }
    }
  }
  return $ret . $subdefs;
}
sub has_parmref($$$) {
  my ($chunkparts, $impl_parms, $direct_parms) = @_;
  $chunkparts = $chunks{$chunkparts};
  for(my $i = 0; $i <= $#$chunkparts; $i += 2) {
    my $low = $$chunkparts[$i];
    my $high = $$chunkparts[$i + 1];
    for(;$low <= $high; $low++) {
      if($notext[$low] =~ /^\@use (.*)$/) {
        return 1 if $$impl_parms{$1} and (not $direct_parms or not $$direct_parms{$1});
        foreach my $pass ($1 =~ /(?<!@)<<(.*?)>>/) {
          return 1 if $$impl_parms{$1} and (not $direct_parms or not $$direct_parms{$1});
        }
        if($chunks{$1}) {
          return 1 if has_parmref($1, $impl_parms, undef);
        } else {
          my ($best, %best_parms) = find_best_def(idx_to_loc($low), $1);
          next if not $best;
          my %new_impl = (%$impl_parms);
          foreach my $p (keys %best_parms) {
            $new_impl{$p} = $best_parms{$p};
          }
          return 1 if has_parmref($best, \%new_impl, \%best_parms);
        }
      }
    }
  }
  return 0;
}

my $lineno = 1; my $file = '<stdin>';
my ($codeline, $codefile, $curchunk);
push @notext, '';
while(<STDIN>) {
  print $_;
   if(/^\@begin code( |$)/) {
    $codeline = $lineno;
    $codefile = $file;
    push @notext, $_;
  } elsif(/^\@defn (.*)$/) {
    unless($codeline) {
      print STDERR "$file:$lineno: invalid chunk syntax\n";
      exit 1;
    }
    $curchunk = $1;
    $notext[$#notext] .= $_;
    $textfile[$#notext] = $file;
    $textline[$#notext] = $lineno;
    $chunks{$curchunk} = [] if not $chunks{$curchunk};
    push @{$chunks{$curchunk}}, $#notext;
    my $strip = strip_chunkname $curchunk;
    $parmchunks{$strip} = {} if not $parmchunks{$strip};
    ${$parmchunks{$strip}}{$curchunk} = 1;
    push @notext, '';
  } elsif(/^\@end code( |$)/) {
    unless($curchunk) {
      print STDERR "$file:$lineno: invalid chunk syntax\n";
      exit 1;
    }
    $notext[$#notext] .= $_;
    push @{$chunks{$curchunk}}, $#notext;
    push @notext, '';
    $codeline = $codefile = $curchunk = undef;
  } elsif(/^\@use .*$/) {
    if($curchunk) {
      push @notext, $_;
      $textfile[$#notext] = $file;
      $textline[$#notext] = $lineno;
      push @notext, '';
    }
  } elsif(/^\@fatal( |$)/) {
    exit 1;
  } elsif(/^\@(index |)nl( |$)/) {
    $lineno++;
    $notext[$#notext] .= $_ if $codeline;
  } elsif(/^\@file (.*)$/) {
    $file = $1;
    $lineno = 1;
    $notext[$#notext] .= $_ if $codeline;
  } elsif(/^\@line (.*)$/) {
    $lineno = $1 - 1;
    $notext[$#notext] .= $_ if $codeline;
  } else {
    $notext[$#notext] .= $_ if $codeline;
  }
}

DUMP: for(my $i = 0; $i <= $#notext; $i++) {
  my $u = $notext[$i];
  next if $u !~ /^\@use (.*)$/;
  my $curchunk = $1;
  next if $chunks{$curchunk};
  my ($best, %best_parms) = find_best_def(idx_to_loc($i), $curchunk);
  next unless $best;
  foreach my $v (values %best_parms) {
    foreach my $bad_val ($v =~ /(?<!@)(<<@.*?(?<!@)>>)/) {
      # since we're not notangle, we have to expand every single chunk
      # so raising an error on unknown parm is not possible
      # for now, just go ahead and leave unexpanded
      #print "$textfile[$i]:$textline[$i]: " .
      #      "undefined parameter $bad_val\n";
      last; # next DUMP;
    }
  }
  print dump_def($curchunk, $curchunk . '<<>>', $best, %best_parms);
}
