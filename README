This provides filters to extend noweb with parameterized chunks.  It
is a partial rewrite of the code in my build.nw
(https://bitbucket.org/darktjm/literate-build), changing the tangle
part to a filter instead of a tangling back end, and removing the
no-newline feature.  While build.nw is licensed under the Apache
License 2.0, this code is in the Public Domain.

Unlike my other literate code on this site, this noweb file is not
meant to be processed using build.nw.  In fact, it shares code chunk
names with build.nw, making it impossible using the current build.nw.
Maybe one day when I reimplement explicit import/export, this
limitation will go away.  Until then, or until I rename those chunks
here or there, there is no color syntax highlighting of code chunks,
and there are many mostly blank pages and other weird gaps, and it's
hard to tell where the boundaries are between code and documentation.

All files in this project are derived from parm.nw, except for this
README.  They are provided for convenience only; the authoritative
source is the noweb file.

The official documentation is the noweb file; weave it and display it.

  noweave -delay -filter l2h -index -html parm.nw | htmltoc > parm.html
  # view parm.html
  noweave -delay -index parm.nw > parm.tex
  pdflatex parm; pdflatex parm; pdflatex parm
  # view parm.pdf

The introduction contains the syntax, repeated here:

* A chunk name used in a chunk definition line may contain parameter
  definitions in parentheses. All parameter names begin with an
  at-sign (@). The only characters forbidden in parameter names are
  close-parentheses and invalid NoWeb syntax. Thus the parameter
  name is terminated by its closing parenthesis. Parameter
  definition syntax within in-line code is ignored.

  For example:

    <<macro (@arg1) with -(@arg2)- (but not [[(@arg3)]])>>=
    text
    @

  The parameters are @arg1 and @arg2.

* No chunk name may begin with an at-sign (@). That is, the names
  starting with an at-sign are reserved for parameter names.

* Chunk references beginning with an at-sign (@) expand to the
  parameter with that name, as defined by the closest parent taking
  a parameter of that name. When weaved, such references are not
  linked anywhere, and they are not added to the index. When
  tangled, the -L option is ignored.

  For example:

    <<macro (@arg)>>=
    text <<@arg>>
    <<other>>
    @
    <<macro2 (@arg)>>=
    text2 <<@arg>>
    <<other>>
    @
    <<other>>=
    <<@arg>>
    @

* When expanded within macro, both @arg and other will expand using
  macro's argument. When expanded within macro2, both @arg and other
  will expand using macro2's argument.

* A chunk reference consisting of the name of a chunk taking
  parameters, with all parameter references replaced by NoWeb
  in-line code segments, represents an expansion of the reference
  with the parameters taking the value of the code within the
  in-line code segments in their respective positions. No expansion
  is done within the code segments except for parameter references;
  these may be used to pass parameters on to another macro.

  For example:

    <<macro (@arg)>>=
    text <<@arg>>
    @
    <<macro2 (@arg)>>=
    <<macro [[and <<@arg>>]]>>
    @
    <<macro3 (@arg)>>=
    <<macro4>>
    @
    <<macro4>>=
    can reference <<@arg>> of macro3.
    @
    <<caller>>=
    text <<macro [[text2]]>> <<macro2 [[text3]]>>
    <<macro3 [[text4]]>>
    @

  The caller chunk expands to
    text text text2 text and text3
    can reference text4 of macro3.

* When more than one parameterized chunk could be used to replace a
  reference, the one with the least parameter replacements is
  chosen. For equal numbers, the one which does not contain the
  earliest parameter replacement is chosen.

  For example:

    <<macro (@arg1) and (@arg2)>>=
    text <<@arg1>> blah <<@arg2>>
    @
    <<macro [[1]] and (@arg)>>=
    text blah blah <<@arg>>
    @
    <<macro (@arg) and [[2]]>>=
    text blah blah blah <<@arg>>
    @
    <<*>>=
    <<macro [[a]] and [[b]]>> -- one blah
    <<macro [[1]] and [[b]]>> -- two blahs
    <<macro [[a]] and [[2]]>> -- three blahs
    <<macro [[1]] and [[2]]>> -- two blahs and a warning
    @

The filter names and usage instructions are in the final section, but
mostly repeated here:

Extract the following four chunks from the noweb file, make them
executable (or always prefix them with the path to perl in filter
command lines), and use as described:

* nt-parm --- always use this as a filter when tangling.

* nw-parm-preidx --- always use this as a filter before indexing when
  weaving, before indexing (or implicit indexing, such as -x, -index, etc.).

* nw-parm-postidx: always use this as a filter when weaving, after
  indexing (or implicit indexing).  If no indexing is done at all, use
  both of these filters with nothing in between.

* noroots-parm: use this in place of noroots.

For example, to extract the programs and prepare them for use:

  for x in nt-parm nw-parm-preidx nt-parm-postidx noroots-parm; do
    notangle -R$x parm.nw >$x
    chmod +x $x
  done

For example, to use:

  notangle -filter ./nt-parm -R'myroot' mystuff.nw > out
  noweave -filter ./nw-parm-preidx -index \
          -filter ./nw-parm-postidx mystuff.nw > mystuff.tex

If you are weaving a file that is meant to be tangled together with
other files, those other files need to be on the nw-parm-preidx
command line.  Repeating the main input file is harmless.  For
example, if x.nw and y.nw are normally tangled together, but weaved
separately:

  notangle -filter ./nt-parm -R'myroot' x.nw y.nw > out
  noweave -filter "./nw-parm-preidx y.nw" -index \
          -filter ./nw-parm-postidx x.nw > x.tex
  noweave -filter "./nw-parm-preidx x.nw" -index \
          -filter ./nw-parm-postidx y.nw > y.tex
