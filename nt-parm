#!/bin/sh
#!perl
# GENERATED FILE:  DO NOT EDIT OR READ THIS FILE
# Instead, read or edit the NoWeb file(s) from which this was generated.
eval 'exec perl -x -f "$0" "$@"'
  if 0;

use strict;

my (@notext, @textfile, @textline, %chunks);
my %parmchunks;
# note: $parm_re's first capture group is the parameter
#       $parm_re's second cpature group is for recursion (ignore!)
my $parm_re = '(\(\@[^)]*\)|(?<!@)\[\[((?:[^][]|\[(?-1)\])*)\]\])';
sub strip_chunkname($)
{
  my $n = shift;
  $n =~ s/$parm_re/(@)/g;
  return $n;
}
sub find_best_def($$) {
  my ($loc, $curchunk) = @_;
  my $pchunks = $parmchunks{strip_chunkname $curchunk};
  return if not $pchunks;
  my ($best, %best_parms);
  my $best_len = length $curchunk; # larger than all possible lengths
  my @best_parms_loc;
  my (@ambig, $bad_ambig);
  PCHUNK: foreach my $may (keys %$pchunks) {
    my %may_parms;
    my $len = 0;
    my @may_parms_loc;
    my $parm_loc = 0;
    my $mayrest = $may;
    my $currest = $curchunk;
    while($mayrest =~ /$parm_re(.*)/) {
      $parm_loc++;
      my $mayp = $1;
      $mayrest = $3;
      $currest =~ /$parm_re(.*)/;
      my $curp = $1;
      $currest = $3;
      next if $curp eq $mayp;
      next PCHUNK if substr($mayp, 0, 1) eq "[" ||
                     substr($curp, 0, 1) eq "(";
      $may_parms{substr($mayp, 1, -1)} = substr($curp, 2, -2);
      $len++;
      push @may_parms_loc, $parm_loc;
    }
    next PCHUNK if $len > $best_len;
    if($len == $best_len) {
      $ambig[0] = $best if $#ambig == 0;
      push @ambig, $may;
      my $i;
      for($i = 0; $i <= $#may_parms_loc; $i++) {
        next PCHUNK if $may_parms_loc[$i] < $best_parms_loc[$i];
        last if $may_parms_loc[$i] > $best_parms_loc[$i];
      }
      $bad_ambig = 1 if $i == $#may_parms_loc + 1;
      if($bad_ambig) {
        $best = undef;
        next PCHUNK;
      }
    } else {
      @ambig = undef;
      $bad_ambig = undef;
    }
    $best = $may;
    %best_parms = (%may_parms);
    $best_len = $len;
    @best_parms_loc = (@may_parms_loc);
  }
  if($#ambig > 0) {
    print STDERR $loc;
    print STDERR "fatal: unresolvable " if $bad_ambig;
    print STDERR "ambiguous expansion of <<$curchunk>>:\n";
    foreach my $may (@ambig) {
      print STDERR "  <<$may>>";
      print STDERR " (chosen)" if $may eq $best;
      print STDERR "\n";
    }
    if($bad_ambig) {
      print "\@fatal ambiguous expansion\n";
      exit 1;
    }
  }
  return ($best, %best_parms);
}

sub idx_to_loc($) {
  my $idx = $_[0];
  return "$textfile[$idx]:$textline[$idx]: ";
}
sub dump_def($$%) {
  my ($old, $new, %parms) = @_;
  my ($ret, $subdefs);
  $chunks{$new} = [];
  my $chunk = $chunks{$old};
  for(my $c = 0; $c <= $#$chunk; $c += 2) {
    my $i = $$chunk[$c];
    my $last = $$chunk[$c + 1];
    $ret .= "\@file $textfile[$i]\n\@line " . ($textline[$i] + 1) . "\n";
    $ret .= substr($notext[$i], 0, -(length($old) + 1)) . $new . "\n";
    for($i++; $i <= $last; $i++) {
      my $t = $notext[$i];
      if($t !~ /^\@use (.*)$/) {
        $ret .= $t;
      } else {
        if(substr($1, 0, 1) eq '@') {
          if($parms{$1}) {
            $ret .= "\@text $parms{$1}\n";
          } else {
            # again, we're not notangle, so can't raise errors here
            #print STDERR "$textfile[$i]:$textline[$i]: " .
            #             "undefined parameter <<$1>>\n" unless $parms{$1};
            # but we can force notangle to raise an error:
            $ret .= $t;
          }
        } else {
          my $new_chunk = $1;
          my ($best, %best_parms) = find_best_def(idx_to_loc($i), $new_chunk);
          next if not $best;
          my %new_parms = (%parms);
          #my $parms_changed;
          foreach my $p (keys %best_parms) {
            my $v = $best_parms{$p};
            my $newv = '';
            my $vrest = $v;
            while($vrest =~ /(.*?)<<(@.*?)(?<!@)>>(.*)/) {
              $newv .= $1 . $parms{$2};
              $vrest = $3;
              # once again, can't print error because we're not notangle
              #print STDERR "$textfile[$i]:$textline[$i]: " .
              #             "undefined parameter <<$2>>\n" if not $parms{$2};
              # instead, silently ignore/replace with blanks
            }
            $newv .= $vrest;
            if($newv ne $v) {
              $best_parms{$p} = $newv; # not needed if find_best_def used below
              $new_chunk =~ s/(?<!@)\[\[\Q$v\E\]\]/[[$newv]]/;
              #$parms_changed = 1;
            }
          }
          # undocumented feature: find better match if var replacements were made
          #($best, %best_parms) = find_best_def(idx_to_loc($i), $new_chunk)
          #   if $parms_changed;
          # add new parms to global set of parms for recursive call
          foreach my $p (keys %best_parms) {
            $new_parms{$p} = $best_parms{$p};
          }
          # add w/ uniquifier prefix if implicit parms referenced
          my $has_ref = has_implref($best, \%new_parms, \%best_parms);
          my $sub_name = $has_ref ? $new . '<<>>' . $new_chunk : $new_chunk;
          $ret .= "\@use $sub_name\n";
          # skip if already there
          next if $chunks{$sub_name};
          # skip if plain reference with no parm refs
          next if $sub_name eq $best;
          $subdefs .= dump_def($best, $sub_name, %new_parms);
        }
      }
    }
  }
  return $ret . $subdefs;
}
sub has_implref($$$) {
  my ($chunkparts, $impl_parms, $direct_parms) = @_;
  $chunkparts = $chunks{$chunkparts};
  for(my $i = 0; $i <= $#$chunkparts; $i += 2) {
    my $low = $$chunkparts[$i];
    my $high = $$chunkparts[$i + 1];
    for(;$low <= $high; $low++) {
      if($notext[$low] =~ /^\@use (.*)$/) {
        next if $$direct_parms{$1};
        return 1 if $$impl_parms{$1};
        next if substr($1, 0, 1) eq '@';
        my ($best, %best_parms) = find_best_def(idx_to_loc($low), $1);
        next if not $best;
        my %new_impl = (%$impl_parms);
        foreach my $p (keys %best_parms) {
          my $vrest = $best_parms{$p};
          while($vrest =~ /<<(@.*?)(?<!@)>>(.*)/) {
            return 1 if $$impl_parms{$1} && not $$direct_parms{$1};
            $vrest = $2;
          }
          $new_impl{$p} = 1;
        }
        return 1 if has_implref($best, \%new_impl, \%best_parms);
      }
    }
  }
  return 0;
}

my $lineno = 1; my $file = '<stdin>';
my ($codeline, $codefile, $curchunk);
push @notext, '';
while(<STDIN>) {
  print $_;
   if(/^\@begin code( |$)/) {
    $codeline = $lineno;
    $codefile = $file;
    push @notext, $_;
  } elsif(/^\@defn (.*)$/) {
    unless($codeline) {
      print STDERR "$file:$lineno: invalid chunk syntax\n";
      exit 1;
    }
    if(substr($1, 0, 1) eq '@') {
      print STDERR "$file:$lineno: "
      print STDERR "initial @ is reserved for parameter names\n";
      print "\@nl\n\@end code\n" # prevent malformed code messages
      print "\@fatal invalid chunk name\n";
      exit 1;
    }
    $curchunk = $1;
    $notext[$#notext] .= $_;
    $textfile[$#notext] = $file;
    $textline[$#notext] = $lineno;
    $chunks{$curchunk} = [] if not $chunks{$curchunk};
    push @{$chunks{$curchunk}}, $#notext;
    my $strip = strip_chunkname $curchunk;
    $parmchunks{$strip} = {} if not $parmchunks{$strip};
    ${$parmchunks{$strip}}{$curchunk} = 1;
    push @notext, '';
  } elsif(/^\@end code( |$)/) {
    unless($curchunk) {
      print STDERR "$file:$lineno: invalid chunk syntax\n";
      exit 1;
    }
    $notext[$#notext] .= $_;
    push @{$chunks{$curchunk}}, $#notext;
    push @notext, '';
    $codeline = $codefile = $curchunk = undef;
  } elsif(/^\@use .*$/) {
    if($curchunk) {
      push @notext, $_;
      $textfile[$#notext] = $file;
      $textline[$#notext] = $lineno;
      push @notext, '';
    }
  } elsif(/^\@fatal( |$)/) {
    exit 1;
  } elsif(/^\@(index |)nl( |$)/) {
    $lineno++;
    $notext[$#notext] .= $_ if $codeline;
  } elsif(/^\@file (.*)$/) {
    $file = $1;
    $lineno = 1;
    $notext[$#notext] .= $_ if $codeline;
  } elsif(/^\@line (.*)$/) {
    $lineno = $1 - 1;
    $notext[$#notext] .= $_ if $codeline;
  } else {
    $notext[$#notext] .= $_ if $codeline;
  }
}

for(my $i = 0; $i <= $#notext; $i++) {
  my $u = $notext[$i];
  next if $u !~ /^\@use (.*)$/;
  my $curchunk = $1;
  next if $chunks{$curchunk};
  my ($best, %best_parms) = find_best_def(idx_to_loc($i), $curchunk);
  next unless $best;
  # since we're not notangle, we have to expand every single chunk
  # so raising an error on unknown parm is not possible
  # for now, just go ahead and leave unexpanded
  #foreach my $v (values %best_parms) {
  #  foreach my $bad_val ($v =~ /<<(@.*?)(?<!@)>>)/) {
  #
  #    print "$textfile[$i]:$textline[$i]: " .
  #          "undefined parameter $bad_val\n";
  #  }
  #}
  print dump_def($best, $curchunk, %best_parms);
}
