#!/bin/sh
#!perl
# GENERATED FILE:  DO NOT EDIT OR READ THIS FILE
# Instead, read or edit the NoWeb file(s) from which this was generated.
eval 'exec perl -x -f "$0" "$@"'
  if 0;

use strict;

# note: $parm_re's first capture group is the parameter
#       $parm_re's second cpature group is for recursion (ignore!)
my $parm_re = '(\(\@[^)]*\)|(?<!@)\[\[((?:[^][]|\[(?-1)\])*)\]\])';
sub strip_chunkname($)
{
  my $n = shift;
  $n =~ s/$parm_re/(@)/g;
  return $n;
}

my (%chunks, %parmchunks);

foreach my $a (@ARGV) {
#  open(my $fh, "markup $a|");
  open(my $fh, "$a");
  while(<$fh>) {
#    next unless(m/^\@defn (.*)$/);
    next unless(m/^<<(.*)>>=$/);
    $chunks{$1} = 1;
    my $s = strip_chunkname($1);
    $parmchunks{$s} = {} if not $parmchunks{$s};
    ${$parmchunks{$s}}{$1} = 1;
  }
  close $fh;
}
my @file = <STDIN>;
foreach my $l (@file) {
  next unless($l =~ m/^\@defn (.*)$/);
  $chunks{$1} = 1;
  my $s = strip_chunkname($1);
  $parmchunks{$s} = {} if not $parmchunks{$s};
  ${$parmchunks{$s}}{$1} = 1;
}
sub find_best_def($$) {
  my ($loc, $curchunk) = @_;
  my $pchunks = $parmchunks{strip_chunkname $curchunk};
  return if not $pchunks;
  my ($best, %best_parms);
  my $best_len = length $curchunk; # larger than all possible lengths
  my @best_parms_loc;
  my (@ambig, $bad_ambig);
  PCHUNK: foreach my $may (keys %$pchunks) {
    my %may_parms;
    my $len = 0;
    my @may_parms_loc;
    my $parm_loc = 0;
    my $mayrest = $may;
    my $currest = $curchunk;
    while($mayrest =~ /$parm_re(.*)/) {
      $parm_loc++;
      my $mayp = $1;
      $mayrest = $3;
      $currest =~ /$parm_re(.*)/;
      my $curp = $1;
      $currest = $3;
      next if $curp eq $mayp;
      next PCHUNK if substr($mayp, 0, 1) eq "[" ||
                     substr($curp, 0, 1) eq "(";
      $may_parms{substr($mayp, 1, -1)} = substr($curp, 2, -2);
      $len++;
      push @may_parms_loc, $parm_loc;
    }
    next PCHUNK if $len > $best_len;
    if($len == $best_len) {
      $ambig[0] = $best if $#ambig == 0;
      push @ambig, $may;
      my $i;
      for($i = 0; $i <= $#may_parms_loc; $i++) {
        next PCHUNK if $may_parms_loc[$i] < $best_parms_loc[$i];
        last if $may_parms_loc[$i] > $best_parms_loc[$i];
      }
      $bad_ambig = 1 if $i == $#may_parms_loc + 1;
      if($bad_ambig) {
        $best = undef;
        next PCHUNK;
      }
    } else {
      @ambig = undef;
      $bad_ambig = undef;
    }
    $best = $may;
    %best_parms = (%may_parms);
    $best_len = $len;
    @best_parms_loc = (@may_parms_loc);
  }
  if($#ambig > 0) {
    print STDERR $loc;
    print STDERR "fatal: unresolvable " if $bad_ambig;
    print STDERR "ambiguous expansion of <<$curchunk>>:\n";
    foreach my $may (@ambig) {
      print STDERR "  <<$may>>";
      print STDERR " (chosen)" if $may eq $best;
      print STDERR "\n";
    }
    if($bad_ambig) {
      print "\@fatal ambiguous expansion\n";
      exit 1;
    }
  }
  return ($best, %best_parms);
}

foreach my $l (@file) {
  if($l =~ /^\@use ([^@].*\[\[.*\]\].*)$/) {
    my ($best,) = find_best_def('', $1);
    if($best and $best ne $1) {
      my $cur = '';
      my ($b, $c) = ($best, $1);
      while($b =~  /$parm_re(.*)/) {
        my $bp = $1;
        $b = $3;
        $c =~ /^(.*?)$parm_re(.*)/;
        my $cp = $2;
        $c = $4;
        $cur .= $1;
        if($cp eq $bp) {
          $cur .= $cp;
        } else {
          $cur .= '[[' . $cp . ']]';
        }
      }
      $cur .= $c;
      print "\@nwparmcall $cur\n\@use $best\n";
    } else {
      print $l;
    }
  } else {
    $l =~ s/^\@use \@/\@nwparmuse \@/;
    print $l;
  }
}
