#!/bin/sh
#!perl
# GENERATED FILE:  DO NOT EDIT OR READ THIS FILE
# Instead, read or edit the NoWeb file(s) from which this was generated.
eval 'exec perl -x -f "$0" "$@"'
  if 0;

use strict;

my $LIB = `notangle -filter 'echo \$LIB >&3' /dev/null 2>/dev/null 3>&1`;
chomp $LIB;

my (%chunks, %parmchunks, %use);

open(my $f, "-|", "$LIB/markup", @ARGV);

# note: $parm_re's first capture group is the parameter
#       $parm_re's second cpature group is for recursion (ignore!)
my $parm_re = '(\(\@[^)]*\)|(?<!@)\[\[((?:[^][]|\[(?-1)\])*)\]\])';
sub strip_chunkname($)
{
  my $n = shift;
  $n =~ s/$parm_re/(@)/g;
  return $n;
}

while(<$f>) {
  if(/^\@quote$/) {
    while(<$f>) {
      last if(/\@endquote$/);
    }
  } elsif(/^\@defn (.*)$/) {
    $chunks{$1} = 1;
    my $s = strip_chunkname($1);
    $parmchunks{$s} = {} if not $parmchunks{$s};
    ${$parmchunks{$s}}{$1} = 1;
  } elsif(/^\@use (.*)$/) {
    $use{$1} = 1;
  }
}

sub find_best_def($$) {
  my ($loc, $curchunk) = @_;
  my $pchunks = $parmchunks{strip_chunkname $curchunk};
  return if not $pchunks;
  my ($best, %best_parms);
  my $best_len = length $curchunk; # larger than all possible lengths
  my @best_parms_loc;
  my (@ambig, $bad_ambig);
  PCHUNK: foreach my $may (keys %$pchunks) {
    my %may_parms;
    my $len = 0;
    my @may_parms_loc;
    my $parm_loc = 0;
    my $mayrest = $may;
    my $currest = $curchunk;
    while($mayrest =~ /$parm_re(.*)/) {
      $parm_loc++;
      my $mayp = $1;
      $mayrest = $3;
      $currest =~ /$parm_re(.*)/;
      my $curp = $1;
      $currest = $3;
      next if $curp eq $mayp;
      next PCHUNK if substr($mayp, 0, 1) eq "[" ||
                     substr($curp, 0, 1) eq "(";
      $may_parms{substr($mayp, 1, -1)} = substr($curp, 2, -2);
      $len++;
      push @may_parms_loc, $parm_loc;
    }
    next PCHUNK if $len > $best_len;
    if($len == $best_len) {
      $ambig[0] = $best if $#ambig == 0;
      push @ambig, $may;
      my $i;
      for($i = 0; $i <= $#may_parms_loc; $i++) {
        next PCHUNK if $may_parms_loc[$i] < $best_parms_loc[$i];
        last if $may_parms_loc[$i] > $best_parms_loc[$i];
      }
      $bad_ambig = 1 if $i == $#may_parms_loc + 1;
      if($bad_ambig) {
        $best = undef;
        next PCHUNK;
      }
    } else {
      @ambig = undef;
      $bad_ambig = undef;
    }
    $best = $may;
    %best_parms = (%may_parms);
    $best_len = $len;
    @best_parms_loc = (@may_parms_loc);
  }
  if($#ambig > 0) {
    print STDERR $loc;
    print STDERR "fatal: unresolvable " if $bad_ambig;
    print STDERR "ambiguous expansion of <<$curchunk>>:\n";
    foreach my $may (@ambig) {
      print STDERR "  <<$may>>";
      print STDERR " (chosen)" if $may eq $best;
      print STDERR "\n";
    }
    if($bad_ambig) {
      print "\@fatal ambiguous expansion\n";
      exit 1;
    }
  }
  return ($best, %best_parms);
}

for my $u (keys %use) {
  if(substr($b, 0, 1) ne '@') {
    my ($b,) = find_best_def('', $u);
    $use{$b} = 1 if $b;
  }
}
for my $d (keys %chunks) {
  print "<<$d>>\n" unless $use{$d};
}
